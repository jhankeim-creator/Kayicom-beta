from fastapi import FastAPI, APIRouter, HTTPException, UploadFile, File, Form
from fastapi.responses import JSONResponse
from dotenv import load_dotenv
from starlette.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
import os
import logging
from pathlib import Path
from pydantic import BaseModel, Field, ConfigDict, EmailStr
from typing import List, Optional, Dict, Any
import uuid
from datetime import datetime, timezone, timedelta
from passlib.context import CryptContext
import requests
import base64
from plisio_helper import PlisioHelper


ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# MongoDB connection
mongo_url = os.environ['MONGO_URL']
client = AsyncIOMotorClient(mongo_url)
db = client[os.environ['DB_NAME']]

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Create the main app

import base64
from fastapi import File, UploadFile
import mimetypes

app = FastAPI()
api_router = APIRouter(prefix="/api")

# ==================== MODELS ====================

# User Models
class UserBase(BaseModel):
    email: EmailStr
    full_name: str

class UserCreate(UserBase):
    password: str

class User(UserBase):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    customer_id: str = Field(default_factory=lambda: "")
    role: str = "customer"  # customer or admin
    referral_code: str = Field(default_factory=lambda: str(uuid.uuid4())[:8].upper())
    referred_by: Optional[str] = None  # referral_code of referrer
    referral_balance: float = 0.0  # Balance from referrals
    wallet_balance: float = 0.0  # Store credit / refunds
    credits_balance: int = 0  # Loyalty credits (100 credits = $1)
    is_blocked: bool = False
    blocked_at: Optional[datetime] = None
    blocked_reason: Optional[str] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


async def _generate_unique_customer_id() -> str:
    """Generate a short, human-friendly customer id like KC-12345678."""
    import random

    for _ in range(20):
        cid = f"KC-{random.randint(10_000_000, 99_999_999)}"
        existing = await db.users.find_one({"customer_id": cid}, {"_id": 1})
        if not existing:
            return cid
    # fallback
    return f"KC-{str(uuid.uuid4())[:8].upper()}"

class LoginRequest(BaseModel):
    email: EmailStr
    password: str

# Product Models
class Product(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    description: str
    category: str  # giftcard, topup, subscription, service, crypto
    price: float
    currency: str = "USD"
    image_url: Optional[str] = None
    stock_available: bool = True
    delivery_type: str = "automatic"  # automatic or manual
    subscription_duration_months: Optional[int] = None  # For subscriptions: 2, 6, 12, 24 months
    subscription_auto_check: bool = False  # Auto-check if subscription is still valid
    variant_name: Optional[str] = None  # For variants like "100 Diamonds", "500 UC", etc
    parent_product_id: Optional[str] = None  # Link to parent product for variants
    requires_player_id: bool = False  # For topup products that need player ID
    player_id_label: Optional[str] = None  # Custom label: UID, Character ID, etc
    requires_credentials: bool = False  # For subscription/services that need login credentials
    credential_fields: Optional[List[str]] = None  # e.g. ["email","password"]
    region: Optional[str] = None  # For gift cards: US, EU, ASIA, etc.
    giftcard_category: Optional[str] = None  # For gift cards: Shopping, Gaming, Entertainment, etc.
    is_subscription: bool = False  # Track if this triggers referral payout
    metadata: Optional[Dict[str, Any]] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ProductCreate(BaseModel):
    name: str
    description: str
    category: str
    price: float
    currency: str = "USD"
    image_url: Optional[str] = None
    stock_available: bool = True
    delivery_type: str = "automatic"
    subscription_duration_months: Optional[int] = None
    subscription_auto_check: bool = False
    variant_name: Optional[str] = None
    parent_product_id: Optional[str] = None
    requires_player_id: bool = False
    player_id_label: Optional[str] = None
    requires_credentials: bool = False
    credential_fields: Optional[List[str]] = None
    region: Optional[str] = None
    giftcard_category: Optional[str] = None
    is_subscription: bool = False
    metadata: Optional[Dict[str, Any]] = None

class ProductUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    category: Optional[str] = None
    price: Optional[float] = None
    currency: Optional[str] = None
    image_url: Optional[str] = None
    stock_available: Optional[bool] = None
    delivery_type: Optional[str] = None
    subscription_duration_months: Optional[int] = None
    subscription_auto_check: Optional[bool] = None
    variant_name: Optional[str] = None
    parent_product_id: Optional[str] = None
    requires_player_id: Optional[bool] = None
    player_id_label: Optional[str] = None
    requires_credentials: Optional[bool] = None
    credential_fields: Optional[List[str]] = None
    region: Optional[str] = None
    giftcard_category: Optional[str] = None
    is_subscription: Optional[bool] = None
    metadata: Optional[Dict[str, Any]] = None

# Order Models
class OrderItem(BaseModel):
    product_id: str
    product_name: str
    quantity: int
    price: float
    player_id: Optional[str] = None  # For topup products
    credentials: Optional[Dict[str, str]] = None  # For subscription/services (email/password, etc)

class Order(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    user_id: str
    user_email: str
    items: List[OrderItem]
    total_amount: float
    subtotal_amount: Optional[float] = None
    discount_amount: Optional[float] = None
    coupon_code: Optional[str] = None
    coupon_usage_recorded: Optional[bool] = None
    credits_awarded: Optional[int] = None
    credits_recorded: Optional[bool] = None
    currency: str = "USD"
    payment_method: str  # wallet, crypto_plisio, paypal, skrill, moncash, binance_pay, zelle, cashapp
    payment_status: str = "pending"  # pending, paid, failed, cancelled
    order_status: str = "pending"  # pending, processing, completed, cancelled
    payment_proof_url: Optional[str] = None
    transaction_id: Optional[str] = None
    plisio_invoice_id: Optional[str] = None
    plisio_invoice_url: Optional[str] = None
    delivery_info: Optional[Dict[str, Any]] = None
    refunded_at: Optional[datetime] = None
    refunded_amount: Optional[float] = None
    subscription_start_date: Optional[datetime] = None
    subscription_end_date: Optional[datetime] = None  # For subscription orders
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class OrderCreate(BaseModel):
    items: List[OrderItem]
    payment_method: str
    coupon_code: Optional[str] = None


# ==================== COUPON MODELS ====================

class Coupon(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    code: str
    discount_type: str  # percent or fixed
    discount_value: float
    active: bool = True
    min_order_amount: float = 0.0
    usage_limit: Optional[int] = None
    used_count: int = 0
    expires_at: Optional[datetime] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class CouponCreate(BaseModel):
    code: str
    discount_type: str  # percent or fixed
    discount_value: float
    active: bool = True
    min_order_amount: float = 0.0
    usage_limit: Optional[int] = None
    expires_at: Optional[datetime] = None

class CouponUpdate(BaseModel):
    discount_type: Optional[str] = None
    discount_value: Optional[float] = None
    active: Optional[bool] = None
    min_order_amount: Optional[float] = None
    usage_limit: Optional[int] = None
    expires_at: Optional[datetime] = None

# Payment Models
class ManualPaymentProof(BaseModel):
    order_id: str
    transaction_id: str
    payment_proof_url: str

# Settings Models
class SiteSettings(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = "site_settings"
    site_name: str = "KayiCom"
    logo_url: Optional[str] = None
    primary_color: str = "#3b82f6"
    secondary_color: str = "#8b5cf6"
    support_email: str = "support@kayicom.com"
    plisio_api_key: Optional[str] = None
    mtcgame_api_key: Optional[str] = None
    gosplit_api_key: Optional[str] = None
    z2u_api_key: Optional[str] = None
    resend_api_key: Optional[str] = None
    resend_from_email: Optional[str] = None  # e.g. "KayiCom <no-reply@yourdomain.com>"
    announcement_enabled: Optional[bool] = False
    announcement_message: Optional[str] = None
    trustpilot_enabled: Optional[bool] = False
    trustpilot_business_id: Optional[str] = None
    product_categories: Optional[List[str]] = ["giftcard", "topup", "subscription", "service"]
    # Payment Gateway Settings
    payment_gateways: Optional[dict] = {
        "paypal": {"enabled": True, "email": "", "instructions": ""},
        "airtm": {"enabled": True, "email": "", "instructions": ""},
        "skrill": {"enabled": True, "email": "", "instructions": ""},
        "moncash": {"enabled": True, "email": "", "instructions": ""},
        "binance_pay": {"enabled": True, "email": "", "instructions": ""},
        "zelle": {"enabled": True, "email": "", "instructions": ""},
        "cashapp": {"enabled": True, "email": "", "instructions": ""},
        # Legacy key kept for backwards compatibility
        "crypto_usdt": {"enabled": True, "wallet": "", "instructions": ""}
    }
    # Crypto Exchange Settings
    crypto_settings: Optional[dict] = {
        "buy_rate_usdt": 1.0,
        "sell_rate_usdt": 0.98,
        "transaction_fee_percent": 2.0,
        "min_transaction_usd": 10.0,
        "wallets": {
            "BEP20": "",
            "TRC20": "",
            "MATIC": ""
        }
    }
    # Minutes Transfer (international mobile minutes / airtime)
    minutes_transfer_enabled: Optional[bool] = False
    minutes_transfer_fee_type: Optional[str] = "percent"  # percent or fixed
    minutes_transfer_fee_value: Optional[float] = 0.0  # percent (0-100) or fixed USD
    minutes_transfer_min_amount: Optional[float] = 1.0
    minutes_transfer_max_amount: Optional[float] = 500.0
    minutes_transfer_instructions: Optional[str] = None
    # Social links (follow buttons)
    social_links: Optional[dict] = {
        "facebook": "",
        "instagram": "",
        "tiktok": "",
        "youtube": "",
        "twitter": "",
        "telegram": "",
        "whatsapp": "",
    }
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class SettingsUpdate(BaseModel):
    site_name: Optional[str] = None
    logo_url: Optional[str] = None
    primary_color: Optional[str] = None
    secondary_color: Optional[str] = None
    support_email: Optional[str] = None
    plisio_api_key: Optional[str] = None
    mtcgame_api_key: Optional[str] = None
    gosplit_api_key: Optional[str] = None
    z2u_api_key: Optional[str] = None
    resend_api_key: Optional[str] = None
    resend_from_email: Optional[str] = None
    announcement_enabled: Optional[bool] = None
    announcement_message: Optional[str] = None
    trustpilot_enabled: Optional[bool] = None
    trustpilot_business_id: Optional[str] = None
    product_categories: Optional[List[str]] = None
    payment_gateways: Optional[dict] = None
    crypto_settings: Optional[dict] = None
    minutes_transfer_enabled: Optional[bool] = None
    minutes_transfer_fee_type: Optional[str] = None
    minutes_transfer_fee_value: Optional[float] = None
    minutes_transfer_min_amount: Optional[float] = None
    minutes_transfer_max_amount: Optional[float] = None
    minutes_transfer_instructions: Optional[str] = None
    social_links: Optional[dict] = None

# Bulk Email Model
class BulkEmailRequest(BaseModel):
    subject: str
    message: str
    recipient_type: str  # all, customers, specific_emails
    specific_emails: Optional[List[EmailStr]] = None


# ==================== EMAIL HELPERS ====================

def _frontend_base_url() -> str:
    return os.environ.get("FRONTEND_URL", "http://localhost:3000").rstrip("/")

def _format_dt(dt: datetime) -> str:
    try:
        return dt.astimezone(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
    except Exception:
        return str(dt)

def _send_resend_email(settings: dict, to_email: str, subject: str, html: str):
    """Send one email via Resend. Raises HTTPException on misconfig."""
    if not settings or not settings.get("resend_api_key"):
        raise HTTPException(status_code=400, detail="Resend API key not configured")

    resend_from = settings.get("resend_from_email") or settings.get("support_email")
    if not resend_from:
        raise HTTPException(status_code=400, detail="Resend from email not configured")

    headers = {
        "Authorization": f"Bearer {settings['resend_api_key']}",
        "Content-Type": "application/json",
    }
    resp = requests.post(
        "https://api.resend.com/emails",
        headers=headers,
        json={"from": resend_from, "to": [to_email], "subject": subject, "html": html},
        timeout=20,
    )
    if not (200 <= resp.status_code < 300):
        raise HTTPException(status_code=500, detail=f"Resend send failed: {resp.status_code}: {resp.text[:300]}")


# ==================== SUBSCRIPTION HELPERS ====================

def _parse_subscription_duration(product: dict) -> timedelta:
    """
    Return subscription duration as timedelta.
    Preference:
    - product.subscription_duration_months if present
    - parse product.variant_name like "1 Month", "3 Months", "12 Months", "7 Days", "1 Year"
    - fallback 30 days
    """
    months = product.get("subscription_duration_months")
    if months:
        try:
            return timedelta(days=int(months) * 30)
        except Exception:
            pass

    variant = (product.get("variant_name") or "").strip().lower()
    if variant:
        import re
        # Support English + Haitian Creole + French-ish keywords
        # - day/jou
        # - month/mwa/mois
        # - year/ane/an/ans/years
        m = re.search(r"(\d+)\s*(day|days|jou|month|months|mwa|mois|year|years|ane|an|ans)", variant)
        if m:
            n = int(m.group(1))
            unit = m.group(2)
            if unit in ["day", "days", "jou"]:
                return timedelta(days=n)
            if unit in ["month", "months", "mwa", "mois"]:
                return timedelta(days=n * 30)
            if unit in ["year", "years", "ane", "an", "ans"]:
                return timedelta(days=n * 365)

    return timedelta(days=30)

async def _set_subscription_dates_if_needed(order_id: str) -> Optional[Dict[str, Any]]:
    """If order contains subscription products, set subscription_start_date/end_date."""
    order = await db.orders.find_one({"id": order_id}, {"_id": 0})
    if not order:
        return None

    # Idempotent: don't overwrite if already set
    if order.get("subscription_end_date"):
        return order

    # Only if paid+completed
    if order.get("payment_status") != "paid" or order.get("order_status") != "completed":
        return None

    max_end: Optional[datetime] = None
    start = datetime.now(timezone.utc)

    for item in order.get("items", []):
        product = await db.products.find_one({"id": item.get("product_id")}, {"_id": 0})
        if product and product.get("is_subscription"):
            duration = _parse_subscription_duration(product)
            end = start + duration
            if (max_end is None) or (end > max_end):
                max_end = end

    if not max_end:
        return None

    await db.orders.update_one(
        {"id": order_id},
        {"$set": {
            "subscription_start_date": start.isoformat(),
            "subscription_end_date": max_end.isoformat(),
            "updated_at": datetime.now(timezone.utc).isoformat()
        }}
    )
    updated = await db.orders.find_one({"id": order_id}, {"_id": 0})
    return updated

async def _maybe_send_subscription_emails(order: dict):
    """Send reminder emails (5 days before + at expiry) once per order."""
    if not order:
        return
    if order.get("payment_status") != "paid" or order.get("order_status") != "completed":
        return
    end_raw = order.get("subscription_end_date")
    if not end_raw:
        return
    end = end_raw
    if isinstance(end_raw, str):
        try:
            end = datetime.fromisoformat(end_raw)
        except Exception:
            return
    if not isinstance(end, datetime):
        return

    settings = await db.settings.find_one({"id": "site_settings"}, {"_id": 0}) or {}
    user_email = order.get("user_email")
    if not user_email:
        return

    now = datetime.now(timezone.utc)
    reminder_at = end - timedelta(days=5)

    # Ensure notification collection exists
    # doc: {order_id, type, sent_at}
    async def already_sent(kind: str) -> bool:
        return bool(await db.subscription_notifications.find_one({"order_id": order["id"], "type": kind}))

    def mark_sent(kind: str):
        return db.subscription_notifications.insert_one({
            "id": str(uuid.uuid4()),
            "order_id": order["id"],
            "type": kind,
            "sent_at": datetime.now(timezone.utc).isoformat()
        })

    renew_link = f"{_frontend_base_url()}/products/subscription"

    # 5-day reminder
    if now >= reminder_at and now < end and not await already_sent("reminder_5d"):
        subject = "Subscription renewal reminder"
        html = (
            f"<div style='font-family:Arial,sans-serif'>"
            f"<h2>Reminder: your subscription is ending soon</h2>"
            f"<p>Your subscription will end on <b>{_format_dt(end)}</b>.</p>"
            f"<p>Renew here: <a href='{renew_link}'>{renew_link}</a></p>"
            f"</div>"
        )
        _send_resend_email(settings, user_email, subject, html)
        await mark_sent("reminder_5d")

    # Expired notice
    if now >= end and not await already_sent("expired"):
        subject = "Subscription expired"
        html = (
            f"<div style='font-family:Arial,sans-serif'>"
            f"<h2>Your subscription has expired</h2>"
            f"<p>It ended on <b>{_format_dt(end)}</b>.</p>"
            f"<p>Renew here: <a href='{renew_link}'>{renew_link}</a></p>"
            f"</div>"
        )
        _send_resend_email(settings, user_email, subject, html)
        await mark_sent("expired")


# Withdrawal Models
class Withdrawal(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    user_id: str
    user_email: str
    amount: float
    method: str  # usdt_bep20, btc, paypal
    wallet_address: Optional[str] = None  # For crypto
    paypal_email: Optional[str] = None  # For PayPal
    status: str = "pending"  # pending, approved, rejected, completed
    admin_notes: Optional[str] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class WithdrawalRequest(BaseModel):
    amount: float
    method: str
    wallet_address: Optional[str] = None
    paypal_email: Optional[str] = None
    moncash_phone: Optional[str] = None
    moncash_name: Optional[str] = None

# Crypto Transaction Models
class CryptoTransaction(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    user_id: str
    user_email: str
    transaction_type: str  # buy or sell
    crypto_type: str = "USDT"
    chain: str  # BEP20, TRC20, MATIC
    amount_crypto: float
    amount_usd: float
    exchange_rate: float
    fee: float
    total_usd: float  # amount_usd + fee for buy, amount_usd - fee for sell
    payment_method: Optional[str] = None  # For buy: paypal, moncash, btc, usdt
    wallet_address: Optional[str] = None
    transaction_hash: Optional[str] = None
    status: str = "pending"  # pending, processing, completed, failed
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class CryptoBuyRequest(BaseModel):
    chain: str
    amount_usd: float
    payment_method: str
    wallet_address: str
    transaction_id: Optional[str] = None
    payment_proof: Optional[str] = None

class CryptoSellRequest(BaseModel):
    chain: str
    amount_crypto: float
    payment_method: str  # paypal, moncash, usdt, btc
    receiving_info: str  # Email or wallet address for receiving payment
    transaction_id: Optional[str] = None
    payment_proof: Optional[str] = None

# Crypto Config Model
class CryptoConfig(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = "crypto_config"
    # Exchange rates (USD per 1 USDT)
    buy_rate_bep20: float = 1.02
    sell_rate_bep20: float = 0.98
    buy_rate_trc20: float = 1.02
    sell_rate_trc20: float = 0.98
    buy_rate_matic: float = 1.02
    sell_rate_matic: float = 0.98
    # Fees
    buy_fee_percent: float = 2.0
    sell_fee_percent: float = 2.0
    # Limits
    min_buy_usd: float = 10.0
    max_buy_usd: float = 10000.0
    min_sell_usdt: float = 10.0
    max_sell_usdt: float = 10000.0
    # Confirmations required
    bep20_confirmations: int = 15
    trc20_confirmations: int = 20
    matic_confirmations: int = 10
    # Wallets
    wallet_bep20: Optional[str] = None
    wallet_trc20: Optional[str] = None
    wallet_matic: Optional[str] = None
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


# ==================== AUTH ENDPOINTS ====================

@api_router.post("/auth/register", response_model=User)
async def register(user_data: UserCreate):
    # Check if user exists
    existing = await db.users.find_one({"email": user_data.email})
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    # Hash password
    hashed_password = pwd_context.hash(user_data.password)
    
    # Create user
    user = User(
        email=user_data.email,
        full_name=user_data.full_name,
        role="customer"
    )
    user.customer_id = await _generate_unique_customer_id()
    
    doc = user.model_dump()
    doc['password'] = hashed_password
    doc['created_at'] = doc['created_at'].isoformat()
    
    await db.users.insert_one(doc)
    return user

@api_router.post("/auth/login")
async def login(credentials: LoginRequest):
    user = await db.users.find_one({"email": credentials.email})
    if not user:
        logging.error(f"Login failed: user not found for {credentials.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    if user.get("is_blocked"):
        raise HTTPException(status_code=403, detail="Account is blocked. Contact support.")
    
    # Support both 'password' and 'password_hash' field names
    password_field = 'password_hash' if 'password_hash' in user else 'password'
    logging.info(f"Login attempt for {credentials.email}, using field: {password_field}")
    
    if not pwd_context.verify(credentials.password, user[password_field]):
        logging.error(f"Login failed: incorrect password for {credentials.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    logging.info(f"Login successful for {credentials.email}")

    # Ensure customer_id exists (for legacy users)
    if not user.get("customer_id"):
        cid = await _generate_unique_customer_id()
        await db.users.update_one({"id": user["id"]}, {"$set": {"customer_id": cid}})
        user["customer_id"] = cid

    return {
        "user_id": user['id'],
        "id": user['id'],
        "customer_id": user.get("customer_id"),
        "email": user['email'],
        "username": user.get('username', user.get('full_name', 'User')),
        "role": user['role'],
        "is_blocked": bool(user.get("is_blocked", False))
    }

# ==================== PRODUCT ENDPOINTS ====================

@api_router.get("/products", response_model=List[Product])
async def get_products(category: Optional[str] = None, parent_product_id: Optional[str] = None, q: Optional[str] = None):
    query = {}
    if category:
        query['category'] = category
    if parent_product_id:
        query['parent_product_id'] = parent_product_id
    if q:
        q = q.strip()
        if q:
            query["$or"] = [
                {"name": {"$regex": q, "$options": "i"}},
                {"description": {"$regex": q, "$options": "i"}},
                {"variant_name": {"$regex": q, "$options": "i"}},
                {"giftcard_category": {"$regex": q, "$options": "i"}},
            ]
    
    products = await db.products.find(query, {"_id": 0}).to_list(1000)
    for product in products:
        if isinstance(product.get('created_at'), str):
            product['created_at'] = datetime.fromisoformat(product['created_at'])
    return products

@api_router.get("/products/{product_id}", response_model=Product)
async def get_product(product_id: str):
    product = await db.products.find_one({"id": product_id}, {"_id": 0})
    if not product:
        raise HTTPException(status_code=404, detail="Product not found")
    
    if isinstance(product.get('created_at'), str):
        product['created_at'] = datetime.fromisoformat(product['created_at'])
    return product

@api_router.post("/products", response_model=Product)
async def create_product(product_data: ProductCreate):
    product = Product(**product_data.model_dump())
    doc = product.model_dump()
    doc['created_at'] = doc['created_at'].isoformat()
    
    await db.products.insert_one(doc)
    return product

@api_router.put("/products/{product_id}", response_model=Product)
async def update_product(product_id: str, updates: ProductUpdate):
    existing = await db.products.find_one({"id": product_id})
    if not existing:
        raise HTTPException(status_code=404, detail="Product not found")
    
    update_data = {k: v for k, v in updates.model_dump().items() if v is not None}
    
    if update_data:
        await db.products.update_one({"id": product_id}, {"$set": update_data})
    
    updated = await db.products.find_one({"id": product_id}, {"_id": 0})
    if isinstance(updated.get('created_at'), str):
        updated['created_at'] = datetime.fromisoformat(updated['created_at'])
    return updated

@api_router.delete("/products/{product_id}")
async def delete_product(product_id: str):
    result = await db.products.delete_one({"id": product_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Product not found")
    return {"message": "Product deleted successfully"}


# ==================== COUPON ENDPOINTS ====================

def _normalize_coupon_code(code: str) -> str:
    return (code or "").strip().upper()

async def _get_valid_coupon(code: str, order_amount: float) -> Optional[dict]:
    """Return coupon doc if valid for given amount, else None."""
    normalized = _normalize_coupon_code(code)
    if not normalized:
        return None

    coupon = await db.coupons.find_one({"code": normalized}, {"_id": 0})
    if not coupon:
        return None
    if not coupon.get("active", True):
        return None
    expires_at = coupon.get("expires_at")
    if isinstance(expires_at, str):
        try:
            expires_at = datetime.fromisoformat(expires_at)
        except Exception:
            expires_at = None
    if expires_at and expires_at < datetime.now(timezone.utc):
        return None
    if float(order_amount) < float(coupon.get("min_order_amount", 0.0)):
        return None
    usage_limit = coupon.get("usage_limit")
    if usage_limit is not None and int(coupon.get("used_count", 0)) >= int(usage_limit):
        return None
    return coupon

def _calculate_discount(coupon: dict, subtotal: float) -> float:
    discount_type = coupon.get("discount_type")
    value = float(coupon.get("discount_value", 0.0))
    if value <= 0:
        return 0.0
    if discount_type == "percent":
        return max(0.0, min(subtotal, subtotal * (value / 100.0)))
    if discount_type == "fixed":
        return max(0.0, min(subtotal, value))
    return 0.0

async def _record_coupon_usage_if_needed(order_id: str):
    """Increment coupon usage once per paid order."""
    order = await db.orders.find_one({"id": order_id}, {"_id": 0})
    if not order:
        return
    code = _normalize_coupon_code(order.get("coupon_code"))
    if not code:
        return
    if order.get("coupon_usage_recorded"):
        return
    if order.get("payment_status") != "paid":
        return

    coupon = await db.coupons.find_one({"code": code}, {"_id": 0})
    if not coupon:
        # Still mark recorded to avoid retry loops
        await db.orders.update_one({"id": order_id}, {"$set": {"coupon_usage_recorded": True}})
        return

    usage_limit = coupon.get("usage_limit")
    if usage_limit is not None and int(coupon.get("used_count", 0)) >= int(usage_limit):
        # Coupon exhausted; keep order as-is but mark recorded to avoid retry loops
        await db.orders.update_one({"id": order_id}, {"$set": {"coupon_usage_recorded": True}})
        return

    await db.coupons.update_one({"code": code}, {"$inc": {"used_count": 1}})
    await db.orders.update_one({"id": order_id}, {"$set": {"coupon_usage_recorded": True}})


async def _record_loyalty_credits_if_needed(order_id: str):
    """
    Award loyalty credits once per successful order.
    Rule: each successful (paid + completed) order gives 5 credits,
    only if total_amount >= $10.
    """
    order = await db.orders.find_one({"id": order_id}, {"_id": 0})
    if not order:
        return

    # Only award when fully successful
    if order.get("payment_status") != "paid":
        return
    if order.get("order_status") != "completed":
        return

    # Minimum order amount
    try:
        total_amount = float(order.get("total_amount") or 0.0)
    except Exception:
        total_amount = 0.0
    if total_amount + 1e-9 < 10.0:
        # Mark as recorded to avoid repeatedly re-checking for old small orders
        await db.orders.update_one(
            {"id": order_id},
            {"$set": {"credits_recorded": True, "credits_awarded": 0, "updated_at": datetime.now(timezone.utc).isoformat()}}
        )
        return

    if order.get("credits_recorded"):
        return

    credits = 5
    await db.users.update_one({"id": order["user_id"]}, {"$inc": {"credits_balance": int(credits)}})
    await db.orders.update_one(
        {"id": order_id},
        {"$set": {"credits_recorded": True, "credits_awarded": int(credits), "updated_at": datetime.now(timezone.utc).isoformat()}}
    )
    await db.credits_transactions.insert_one({
        "id": str(uuid.uuid4()),
        "user_id": order["user_id"],
        "user_email": order.get("user_email"),
        "order_id": order_id,
        "type": "earn",
        "credits": int(credits),
        "usd_equivalent": round(float(credits) / 100.0, 2),
        "reason": "Order success reward",
        "created_at": datetime.now(timezone.utc).isoformat()
    })

@api_router.get("/coupons/validate")
async def validate_coupon(code: str, amount: float):
    coupon = await _get_valid_coupon(code, amount)
    if not coupon:
        raise HTTPException(status_code=400, detail="Invalid coupon")
    discount = _calculate_discount(coupon, float(amount))
    return {
        "code": coupon["code"],
        "discount_amount": discount,
        "total_after_discount": float(amount) - discount
    }

@api_router.get("/coupons", response_model=List[Coupon])
async def list_coupons():
    coupons = await db.coupons.find({}, {"_id": 0}).sort("created_at", -1).to_list(500)
    for c in coupons:
        if isinstance(c.get("created_at"), str):
            c["created_at"] = datetime.fromisoformat(c["created_at"])
        if isinstance(c.get("expires_at"), str):
            try:
                c["expires_at"] = datetime.fromisoformat(c["expires_at"])
            except Exception:
                c["expires_at"] = None
    return coupons

@api_router.post("/coupons", response_model=Coupon)
async def create_coupon(data: CouponCreate):
    code = _normalize_coupon_code(data.code)
    if not code:
        raise HTTPException(status_code=400, detail="Coupon code required")
    if data.discount_type not in ["percent", "fixed"]:
        raise HTTPException(status_code=400, detail="Invalid discount_type")
    if data.discount_value <= 0:
        raise HTTPException(status_code=400, detail="discount_value must be > 0")

    existing = await db.coupons.find_one({"code": code})
    if existing:
        raise HTTPException(status_code=400, detail="Coupon code already exists")

    coupon = Coupon(
        code=code,
        discount_type=data.discount_type,
        discount_value=float(data.discount_value),
        active=bool(data.active),
        min_order_amount=float(data.min_order_amount or 0.0),
        usage_limit=data.usage_limit,
        expires_at=data.expires_at,
    )
    doc = coupon.model_dump()
    doc["created_at"] = coupon.created_at.isoformat()
    if coupon.expires_at:
        doc["expires_at"] = coupon.expires_at.isoformat()
    await db.coupons.insert_one(doc)
    return coupon

@api_router.put("/coupons/{coupon_id}", response_model=Coupon)
async def update_coupon(coupon_id: str, updates: CouponUpdate):
    existing = await db.coupons.find_one({"id": coupon_id}, {"_id": 0})
    if not existing:
        raise HTTPException(status_code=404, detail="Coupon not found")

    update_data = {k: v for k, v in updates.model_dump().items() if v is not None}
    if "discount_type" in update_data and update_data["discount_type"] not in ["percent", "fixed"]:
        raise HTTPException(status_code=400, detail="Invalid discount_type")
    if "discount_value" in update_data and float(update_data["discount_value"]) <= 0:
        raise HTTPException(status_code=400, detail="discount_value must be > 0")

    # Convert dates to isoformat for storage
    if "expires_at" in update_data and isinstance(update_data["expires_at"], datetime):
        update_data["expires_at"] = update_data["expires_at"].isoformat()

    await db.coupons.update_one({"id": coupon_id}, {"$set": update_data})
    updated = await db.coupons.find_one({"id": coupon_id}, {"_id": 0})
    if isinstance(updated.get("created_at"), str):
        updated["created_at"] = datetime.fromisoformat(updated["created_at"])
    if isinstance(updated.get("expires_at"), str):
        try:
            updated["expires_at"] = datetime.fromisoformat(updated["expires_at"])
        except Exception:
            updated["expires_at"] = None
    return updated

@api_router.delete("/coupons/{coupon_id}")
async def delete_coupon(coupon_id: str):
    res = await db.coupons.delete_one({"id": coupon_id})
    if res.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Coupon not found")
    return {"message": "Coupon deleted"}

# ==================== ORDER ENDPOINTS ====================

@api_router.post("/orders", response_model=Order)
async def create_order(order_data: OrderCreate, user_id: str, user_email: str):
    user_doc = await db.users.find_one({"id": user_id}, {"_id": 0})
    if not user_doc:
        raise HTTPException(status_code=404, detail="User not found")
    if user_doc.get("is_blocked"):
        raise HTTPException(status_code=403, detail="Account is blocked")

    # Validate items & calculate total using authoritative product pricing/settings
    validated_items: List[OrderItem] = []
    subtotal = 0.0
    for item in order_data.items:
        product = await db.products.find_one({"id": item.product_id}, {"_id": 0})
        if not product:
            raise HTTPException(status_code=400, detail=f"Invalid product_id: {item.product_id}")

        quantity = int(item.quantity)
        if quantity <= 0:
            raise HTTPException(status_code=400, detail="Quantity must be at least 1")

        # Required fields validation
        if product.get("requires_player_id") and not (item.player_id and str(item.player_id).strip()):
            label = product.get("player_id_label") or "Player ID"
            raise HTTPException(status_code=400, detail=f"{label} is required for {product.get('name')}")

        if product.get("requires_credentials"):
            creds = item.credentials or {}
            required_fields = product.get("credential_fields") or ["email", "password"]
            missing = [f for f in required_fields if not (creds.get(f) and str(creds.get(f)).strip())]
            if missing:
                raise HTTPException(
                    status_code=400,
                    detail=f"Missing credentials fields for {product.get('name')}: {', '.join(missing)}"
                )

        price = float(product.get("price", item.price))
        subtotal += price * quantity

        validated_items.append(
            OrderItem(
                product_id=product["id"],
                product_name=product.get("name", item.product_name),
                quantity=quantity,
                price=price,
                player_id=item.player_id,
                credentials=item.credentials,
            )
        )
    
    # Apply coupon (if any)
    coupon_code = _normalize_coupon_code(order_data.coupon_code) if order_data.coupon_code else None
    discount_amount = 0.0
    if coupon_code:
        coupon = await _get_valid_coupon(coupon_code, subtotal)
        if not coupon:
            raise HTTPException(status_code=400, detail="Invalid coupon")
        discount_amount = _calculate_discount(coupon, subtotal)

    total = max(0.0, float(subtotal) - float(discount_amount))

    order = Order(
        user_id=user_id,
        user_email=user_email,
        items=validated_items,
        subtotal_amount=subtotal,
        discount_amount=discount_amount if discount_amount > 0 else None,
        coupon_code=coupon_code,
        coupon_usage_recorded=False if coupon_code else None,
        total_amount=total,
        payment_method=order_data.payment_method
    )

    # Wallet payment: instantly mark paid and deduct balance
    if order_data.payment_method == "wallet":
        wallet_balance = float(user_doc.get("wallet_balance", 0.0))
        if wallet_balance + 1e-9 < total:
            raise HTTPException(status_code=400, detail="Insufficient wallet balance")

        await db.users.update_one({"id": user_id}, {"$inc": {"wallet_balance": -float(total)}})
        await db.wallet_transactions.insert_one({
            "id": str(uuid.uuid4()),
            "user_id": user_id,
            "user_email": user_email,
            "order_id": order.id,
            "type": "purchase",
            "amount": -float(total),
            "reason": "Order payment (wallet)",
            "created_at": datetime.now(timezone.utc).isoformat()
        })
        order.payment_status = "paid"
        order.order_status = "processing"
    
    # If crypto payment, create Plisio invoice
    if order_data.payment_method == "crypto_plisio":
        settings = await db.settings.find_one({"id": "site_settings"})
        if settings and settings.get('plisio_api_key'):
            try:
                from plisio_helper import PlisioHelper
                plisio = PlisioHelper(settings['plisio_api_key'])
                
                # Create Plisio invoice for USDT payment
                invoice_response = await plisio.create_invoice(
                    amount=total,
                    currency="USDT",
                    order_name=f"Order {order.id}",
                    order_number=order.id,
                    email=user_email
                )
                
                if invoice_response.get("success"):
                    order.plisio_invoice_id = invoice_response.get("invoice_id")
                    order.plisio_invoice_url = invoice_response.get("invoice_url")
            except Exception as e:
                logging.error(f"Plisio error: {e}")
    
    doc = order.model_dump()
    doc['created_at'] = doc['created_at'].isoformat()
    doc['updated_at'] = doc['updated_at'].isoformat()
    
    await db.orders.insert_one(doc)
    return order

@api_router.get("/orders", response_model=List[Order])
async def get_orders(user_id: Optional[str] = None):
    query = {}
    if user_id:
        query['user_id'] = user_id
    
    orders = await db.orders.find(query, {"_id": 0}).sort("created_at", -1).to_list(1000)
    for order in orders:
        if isinstance(order.get('created_at'), str):
            order['created_at'] = datetime.fromisoformat(order['created_at'])
        if isinstance(order.get('updated_at'), str):
            order['updated_at'] = datetime.fromisoformat(order['updated_at'])
        if isinstance(order.get('refunded_at'), str):
            order['refunded_at'] = datetime.fromisoformat(order['refunded_at'])
        if isinstance(order.get('subscription_start_date'), str):
            order['subscription_start_date'] = datetime.fromisoformat(order['subscription_start_date'])
        if isinstance(order.get('subscription_end_date'), str):
            order['subscription_end_date'] = datetime.fromisoformat(order['subscription_end_date'])
    return orders

@api_router.get("/orders/{order_id}", response_model=Order)
async def get_order(order_id: str):
    order = await db.orders.find_one({"id": order_id}, {"_id": 0})
    if not order:
        raise HTTPException(status_code=404, detail="Order not found")
    
    if isinstance(order.get('created_at'), str):
        order['created_at'] = datetime.fromisoformat(order['created_at'])
    if isinstance(order.get('updated_at'), str):
        order['updated_at'] = datetime.fromisoformat(order['updated_at'])
    if isinstance(order.get('refunded_at'), str):
        order['refunded_at'] = datetime.fromisoformat(order['refunded_at'])
    if isinstance(order.get('subscription_start_date'), str):
        order['subscription_start_date'] = datetime.fromisoformat(order['subscription_start_date'])
    if isinstance(order.get('subscription_end_date'), str):
        order['subscription_end_date'] = datetime.fromisoformat(order['subscription_end_date'])
    return order

@api_router.put("/orders/{order_id}/status")
async def update_order_status(order_id: str, payment_status: Optional[str] = None, order_status: Optional[str] = None):
    updates = {"updated_at": datetime.now(timezone.utc).isoformat()}
    if payment_status:
        updates['payment_status'] = payment_status
    if order_status:
        updates['order_status'] = order_status
    
    result = await db.orders.update_one({"id": order_id}, {"$set": updates})
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Order not found")

    # Record coupon usage once payment is marked as paid
    if payment_status == "paid":
        await _record_coupon_usage_if_needed(order_id)

    # If order is completed, trigger referral payout check (idempotent)
    if order_status == "completed":
        order = await db.orders.find_one({"id": order_id})
        if order:
            # Set subscription dates (if applicable) and run emails
            updated = await _set_subscription_dates_if_needed(order_id)
            try:
                await _maybe_send_subscription_emails(updated or order)
            except Exception as e:
                logging.error(f"Subscription email check error: {e}")
            await check_and_credit_referral(order)
            await _record_loyalty_credits_if_needed(order_id)
    
    return {"message": "Order updated successfully"}

# Delivery Management Model
class DeliveryInfo(BaseModel):
    delivery_details: str  # Credentials, codes, or instructions

@api_router.put("/orders/{order_id}/delivery")
async def update_order_delivery(order_id: str, delivery_info: DeliveryInfo):
    """Update order with delivery information and mark as completed"""
    updates = {
        "delivery_info": {"details": delivery_info.delivery_details, "delivered_at": datetime.now(timezone.utc).isoformat()},
        "order_status": "completed",
        "payment_status": "paid",
        "updated_at": datetime.now(timezone.utc).isoformat()
    }
    
    result = await db.orders.update_one({"id": order_id}, {"$set": updates})
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Order not found")

    # Set subscription dates if this order is a subscription
    order = await _set_subscription_dates_if_needed(order_id)
    if not order:
        order = await db.orders.find_one({"id": order_id}, {"_id": 0})

    # Award loyalty credits once order is completed+paid
    await _record_loyalty_credits_if_needed(order_id)

    # Send delivery email (includes expiry if subscription)
    try:
        settings = await db.settings.find_one({"id": "site_settings"}, {"_id": 0}) or {}
        if order and order.get("user_email"):
            end = order.get("subscription_end_date")
            end_str = ""
            if end:
                if isinstance(end, str):
                    try:
                        end_dt = datetime.fromisoformat(end)
                        end_str = _format_dt(end_dt)
                    except Exception:
                        end_str = str(end)
                elif isinstance(end, datetime):
                    end_str = _format_dt(end)
            extra = f"<p><b>Subscription ends:</b> {end_str}</p>" if end_str else ""
            html = (
                f"<div style='font-family:Arial,sans-serif'>"
                f"<h2>Your order has been delivered</h2>"
                f"<p><b>Order:</b> {order_id}</p>"
                f"<p><b>Delivery details:</b></p>"
                f"<pre style='background:#111827;color:#D1D5DB;padding:12px;border-radius:8px;white-space:pre-wrap'>{delivery_info.delivery_details}</pre>"
                f"{extra}"
                f"</div>"
            )
            _send_resend_email(settings, order["user_email"], "Your delivery is ready", html)
    except Exception as e:
        logging.error(f"Delivery email error: {e}")

    # Schedule/trigger reminder checks immediately
    if order:
        try:
            await _maybe_send_subscription_emails(order)
        except Exception as e:
            logging.error(f"Subscription email check error: {e}")

    return {"message": "Order delivered successfully"}


# ==================== PAYMENT ENDPOINTS ====================

@api_router.post("/payments/manual-proof")
async def upload_payment_proof(proof_data: ManualPaymentProof):
    # Update order with payment proof
    result = await db.orders.update_one(
        {"id": proof_data.order_id},
        {"$set": {
            "payment_proof_url": proof_data.payment_proof_url,
            "transaction_id": proof_data.transaction_id,
            "payment_status": "pending_verification",
            "updated_at": datetime.now(timezone.utc).isoformat()
        }}
    )
    
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Order not found")
    
    return {"message": "Payment proof uploaded successfully"}

@api_router.post("/payments/plisio-callback")
async def plisio_callback(data: Dict[str, Any]):
    # Handle Plisio webhook
    order_id = data.get('order_number')
    status = data.get('status')
    
    if status == 'completed':
        # First try normal orders
        order = await db.orders.find_one({"id": order_id}, {"_id": 0})
        if order:
            await db.orders.update_one(
                {"id": order_id},
                {"$set": {
                    "payment_status": "paid",
                    "order_status": "processing",
                    "updated_at": datetime.now(timezone.utc).isoformat()
                }}
            )
            await _record_coupon_usage_if_needed(order_id)
        else:
            # Then try wallet topups
            topup = await db.wallet_topups.find_one({"id": order_id}, {"_id": 0})
            if topup:
                await db.wallet_topups.update_one(
                    {"id": order_id},
                    {"$set": {
                        "payment_status": "paid",
                        "updated_at": datetime.now(timezone.utc).isoformat()
                    }}
                )
                if not topup.get("credited"):
                    await db.users.update_one({"id": topup["user_id"]}, {"$inc": {"wallet_balance": float(topup["amount"])}})
                    await db.wallet_transactions.insert_one({
                        "id": str(uuid.uuid4()),
                        "user_id": topup["user_id"],
                        "user_email": topup.get("user_email"),
                        "order_id": None,
                        "type": "topup",
                        "amount": float(topup["amount"]),
                        "reason": f"Wallet topup {order_id} (Plisio)",
                        "created_at": datetime.now(timezone.utc).isoformat()
                    })
                    await db.wallet_topups.update_one({"id": order_id}, {"$set": {"credited": True}})
            else:
                # Then try minutes transfers
                transfer = await db.minutes_transfers.find_one({"id": order_id}, {"_id": 0})
                if transfer:
                    await db.minutes_transfers.update_one(
                        {"id": order_id},
                        {"$set": {
                            "payment_status": "paid",
                            "transfer_status": "processing",
                            "updated_at": datetime.now(timezone.utc).isoformat()
                        }}
                    )
    
    return {"status": "ok"}

@api_router.get("/payments/plisio-status/{invoice_id}")
async def check_plisio_status(invoice_id: str):
    settings = await db.settings.find_one({"id": "site_settings"})
    if not settings or not settings.get('plisio_api_key'):
        raise HTTPException(status_code=400, detail="Plisio not configured")
    
    try:
        response = requests.get(
            f"https://api.plisio.net/api/v1/operations/{invoice_id}",
            params={"api_key": settings['plisio_api_key']}
        )
        return response.json()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ==================== SETTINGS ENDPOINTS ====================

@api_router.get("/settings", response_model=SiteSettings)
async def get_settings():
    settings = await db.settings.find_one({"id": "site_settings"}, {"_id": 0})
    if not settings:
        # Create default settings
        default_settings = SiteSettings()
        doc = default_settings.model_dump()
        doc['updated_at'] = doc['updated_at'].isoformat()
        await db.settings.insert_one(doc)
        return default_settings
    
    if isinstance(settings.get('updated_at'), str):
        settings['updated_at'] = datetime.fromisoformat(settings['updated_at'])

    # Never expose secret keys to clients
    for secret_field in ["plisio_api_key", "mtcgame_api_key", "gosplit_api_key", "z2u_api_key", "resend_api_key"]:
        if secret_field in settings:
            settings[secret_field] = None
    return settings

@api_router.put("/settings", response_model=SiteSettings)
async def update_settings(updates: SettingsUpdate):
    update_data = {k: v for k, v in updates.model_dump().items() if v is not None}
    update_data['updated_at'] = datetime.now(timezone.utc).isoformat()
    
    await db.settings.update_one(
        {"id": "site_settings"},
        {"$set": update_data},
        upsert=True
    )
    
    settings = await db.settings.find_one({"id": "site_settings"}, {"_id": 0})
    if isinstance(settings.get('updated_at'), str):
        settings['updated_at'] = datetime.fromisoformat(settings['updated_at'])
    return settings


# ==================== ADMIN: CUSTOMERS ====================

@api_router.get("/admin/customers")
async def admin_list_customers(q: Optional[str] = None, limit: int = 50, skip: int = 0):
    """
    Admin: list customer users with optional search.
    Search matches email/full_name/customer_id (case-insensitive).
    (No auth implemented in this project.)
    """
    limit = max(1, min(int(limit), 500))
    skip = max(0, int(skip))
    query: Dict[str, Any] = {"role": "customer"}
    if q and q.strip():
        s = q.strip()
        query["$or"] = [
            {"email": {"$regex": s, "$options": "i"}},
            {"full_name": {"$regex": s, "$options": "i"}},
            {"customer_id": {"$regex": s, "$options": "i"}},
        ]
    users = await db.users.find(query, {"_id": 0, "password": 0, "password_hash": 0}).sort("created_at", -1).skip(skip).to_list(limit)
    return users


@api_router.get("/admin/customers/{user_id}")
async def admin_get_customer(user_id: str):
    user = await db.users.find_one({"id": user_id, "role": "customer"}, {"_id": 0, "password": 0, "password_hash": 0})
    if not user:
        raise HTTPException(status_code=404, detail="Customer not found")
    return user


class AdminBlockCustomerRequest(BaseModel):
    reason: Optional[str] = None


@api_router.post("/admin/customers/{user_id}/block")
async def admin_block_customer(user_id: str, body: AdminBlockCustomerRequest):
    user = await db.users.find_one({"id": user_id, "role": "customer"}, {"_id": 0})
    if not user:
        raise HTTPException(status_code=404, detail="Customer not found")
    await db.users.update_one(
        {"id": user_id},
        {"$set": {"is_blocked": True, "blocked_at": datetime.now(timezone.utc).isoformat(), "blocked_reason": body.reason}}
    )
    updated = await db.users.find_one({"id": user_id, "role": "customer"}, {"_id": 0, "password": 0, "password_hash": 0})
    return updated or {"message": "Blocked"}


@api_router.post("/admin/customers/{user_id}/unblock")
async def admin_unblock_customer(user_id: str):
    user = await db.users.find_one({"id": user_id, "role": "customer"}, {"_id": 0})
    if not user:
        raise HTTPException(status_code=404, detail="Customer not found")
    await db.users.update_one(
        {"id": user_id},
        {"$set": {"is_blocked": False, "blocked_at": None, "blocked_reason": None}}
    )
    updated = await db.users.find_one({"id": user_id, "role": "customer"}, {"_id": 0, "password": 0, "password_hash": 0})
    return updated or {"message": "Unblocked"}

# ==================== BULK EMAIL ENDPOINTS ====================

@api_router.post("/emails/bulk-send")
async def send_bulk_email(email_data: BulkEmailRequest):
    settings = await db.settings.find_one({"id": "site_settings"})
    if not settings or not settings.get('resend_api_key'):
        raise HTTPException(status_code=400, detail="Resend API key not configured")

    resend_from = settings.get("resend_from_email") or settings.get("support_email")
    if not resend_from:
        raise HTTPException(status_code=400, detail="Resend from email not configured")
    
    # Get recipients based on type
    recipients = []
    if email_data.recipient_type == "all":
        users = await db.users.find({}, {"email": 1, "_id": 0}).to_list(10000)
        recipients = [user['email'] for user in users]
    elif email_data.recipient_type == "customers":
        users = await db.users.find({"role": "customer"}, {"email": 1, "_id": 0}).to_list(10000)
        recipients = [user['email'] for user in users]
    elif email_data.recipient_type == "specific_emails" and email_data.specific_emails:
        recipients = email_data.specific_emails
    
    if not recipients:
        raise HTTPException(status_code=400, detail="No recipients found")
    
    # Send emails via Resend API (send individually to avoid leaking recipient list)
    resend_api_key = settings["resend_api_key"]
    headers = {
        "Authorization": f"Bearer {resend_api_key}",
        "Content-Type": "application/json",
    }

    sent_count = 0
    failed: List[Dict[str, Any]] = []
    for recipient in recipients:
        try:
            resp = requests.post(
                "https://api.resend.com/emails",
                headers=headers,
                json={
                    "from": resend_from,
                    "to": [recipient],
                    "subject": email_data.subject,
                    "html": f"<div style='font-family:Arial,sans-serif;white-space:pre-wrap'>{email_data.message}</div>",
                },
                timeout=20,
            )
            if 200 <= resp.status_code < 300:
                sent_count += 1
            else:
                failed.append({"email": recipient, "status": resp.status_code, "error": resp.text[:300]})
        except Exception as e:
            failed.append({"email": recipient, "status": None, "error": str(e)[:300]})

    return {
        "message": f"Bulk email sent to {sent_count} recipients",
        "sent_count": sent_count,
        "failed_count": len(failed),
        "failed": failed[:20],
        "recipients_preview": recipients[:10] if len(recipients) > 10 else recipients
    }

# ==================== STATS ENDPOINTS ====================

@api_router.post("/subscriptions/run-notifications")
async def run_subscription_notifications():
    """
    Run subscription reminder checks for all paid+completed subscription orders.
    Safe to call from a cron job.
    """
    now = datetime.now(timezone.utc)
    # Find orders with subscription_end_date set
    orders = await db.orders.find(
        {"subscription_end_date": {"$ne": None}, "payment_status": "paid", "order_status": "completed"},
        {"_id": 0}
    ).to_list(5000)

    processed = 0
    for order in orders:
        try:
            # Ensure dates exist (and parseable)
            await _maybe_send_subscription_emails(order)
            processed += 1
        except Exception as e:
            logging.error(f"Subscription notification error for {order.get('id')}: {e}")

    return {"processed": processed, "timestamp": now.isoformat()}

@api_router.get("/stats/dashboard")
async def get_dashboard_stats():
    total_orders = await db.orders.count_documents({})
    total_products = await db.products.count_documents({})
    total_customers = await db.users.count_documents({"role": "customer"})
    
    # Revenue calculation
    pipeline = [
        {"$match": {"payment_status": "paid"}},
        {"$group": {"_id": None, "total": {"$sum": "$total_amount"}}}
    ]
    revenue_result = await db.orders.aggregate(pipeline).to_list(1)
    total_revenue = revenue_result[0]['total'] if revenue_result else 0
    
    # Pending payments
    pending_payments = await db.orders.count_documents({"payment_status": "pending_verification"})
    
    return {
        "total_orders": total_orders,
        "total_products": total_products,
        "total_customers": total_customers,
        "total_revenue": total_revenue,
        "pending_payments": pending_payments
    }

app.add_middleware(
    CORSMiddleware,
    allow_credentials=True,
    allow_origins=os.environ.get('CORS_ORIGINS', '*').split(','),
    allow_methods=["*"],
    allow_headers=["*"],
)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)



# ==================== REFERRAL ENDPOINTS ====================

@api_router.get("/referral/info")
async def get_referral_info(user_id: str):
    """Get user's referral code and balance"""
    user = await db.users.find_one({"id": user_id}, {"_id": 0})
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Count referrals
    referral_count = await db.users.count_documents({"referred_by": user['referral_code']})
    
    return {
        "referral_code": user.get('referral_code'),
        "referral_balance": user.get('referral_balance', 0.0),
        "total_referrals": referral_count,
        "referral_link": f"{os.environ.get('FRONTEND_URL', 'http://localhost:3000')}/register?ref={user.get('referral_code')}"
    }

@api_router.post("/auth/register-with-referral")
async def register_with_referral(user_data: UserCreate, referral_code: Optional[str] = None):
    """Register user with optional referral code"""
    existing = await db.users.find_one({"email": user_data.email})
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    hashed_password = pwd_context.hash(user_data.password)
    
    user = User(
        email=user_data.email,
        full_name=user_data.full_name,
        role="customer"
    )
    user.customer_id = await _generate_unique_customer_id()
    
    doc = user.model_dump()
    doc['password'] = hashed_password
    doc['created_at'] = doc['created_at'].isoformat()
    doc['referral_balance'] = 0.0
    
    # Set referrer if valid code provided
    if referral_code:
        referrer = await db.users.find_one({"referral_code": referral_code})
        if referrer:
            doc['referred_by'] = referral_code
    
    await db.users.insert_one(doc)
    return user

# ==================== WITHDRAWAL ENDPOINTS ====================

@api_router.post("/withdrawals/request")
async def request_withdrawal(withdrawal: WithdrawalRequest, user_id: str, user_email: str):
    """User requests withdrawal"""
    # Check minimum
    if withdrawal.amount < 5.0:
        raise HTTPException(status_code=400, detail="Minimum withdrawal is $5")
    
    # Check user balance
    user = await db.users.find_one({"id": user_id})
    if user and user.get("is_blocked"):
        raise HTTPException(status_code=403, detail="Account is blocked")
    if not user or user.get('referral_balance', 0.0) < withdrawal.amount:
        raise HTTPException(status_code=400, detail="Insufficient balance")
    
    # Validate method-specific fields
    if withdrawal.method in ['usdt_bep20', 'btc'] and not withdrawal.wallet_address:
        raise HTTPException(status_code=400, detail="Wallet address required")
    if withdrawal.method == 'paypal' and not withdrawal.paypal_email:
        raise HTTPException(status_code=400, detail="PayPal email required")
    if withdrawal.method == 'moncash' and (not withdrawal.moncash_phone or not withdrawal.moncash_name):
        raise HTTPException(status_code=400, detail="MonCash phone and name required")
    
    # Create withdrawal request
    withdrawal_doc = {
        "id": str(uuid.uuid4()),
        "user_id": user_id,
        "user_email": user_email,
        "amount": withdrawal.amount,
        "method": withdrawal.method,
        "wallet_address": withdrawal.wallet_address,
        "paypal_email": withdrawal.paypal_email,
        "moncash_phone": withdrawal.moncash_phone if withdrawal.method == 'moncash' else None,
        "moncash_name": withdrawal.moncash_name if withdrawal.method == 'moncash' else None,
        "status": "pending",
        "created_at": datetime.now(timezone.utc).isoformat(),
        "updated_at": datetime.now(timezone.utc).isoformat()
    }
    
    await db.withdrawals.insert_one(withdrawal_doc)
    
    # Deduct from balance (pending)
    await db.users.update_one(
        {"id": user_id},
        {"$inc": {"referral_balance": -withdrawal.amount}}
    )
    
    return {"message": "Withdrawal request submitted", "withdrawal_id": withdrawal_doc['id']}

@api_router.get("/withdrawals/user/{user_id}")
async def get_user_withdrawals(user_id: str):
    """Get user's withdrawal history"""
    withdrawals = await db.withdrawals.find(
        {"user_id": user_id},
        {"_id": 0}
    ).sort("created_at", -1).to_list(100)
    
    return withdrawals

@api_router.get("/withdrawals/all")
async def get_all_withdrawals():
    """Admin: Get all withdrawal requests"""
    withdrawals = await db.withdrawals.find(
        {},
        {"_id": 0}
    ).sort("created_at", -1).to_list(1000)
    
    return withdrawals

@api_router.put("/withdrawals/{withdrawal_id}/status")
async def update_withdrawal_status(withdrawal_id: str, status: str, admin_notes: Optional[str] = None):
    """Admin: Update withdrawal status"""
    if status not in ['approved', 'completed', 'rejected']:
        raise HTTPException(status_code=400, detail="Invalid status")
    
    withdrawal = await db.withdrawals.find_one({"id": withdrawal_id})
    if not withdrawal:
        raise HTTPException(status_code=404, detail="Withdrawal not found")
    
    updates = {
        "status": status,
        "updated_at": datetime.now(timezone.utc).isoformat()
    }
    
    if admin_notes:
        updates['admin_notes'] = admin_notes
    
    # If rejected, refund balance
    if status == 'rejected' and withdrawal['status'] == 'pending':
        await db.users.update_one(
            {"id": withdrawal['user_id']},
            {"$inc": {"referral_balance": withdrawal['amount']}}
        )
    
    await db.withdrawals.update_one({"id": withdrawal_id}, {"$set": updates})
    
    return {"message": f"Withdrawal {status}"}

# ==================== CRYPTO ENDPOINTS ====================

@api_router.get("/crypto/config")
async def get_crypto_config():
    """Get crypto exchange rates and config"""
    config = await db.crypto_config.find_one({"id": "crypto_config"}, {"_id": 0})
    if not config:
        # Create default config
        default_config = CryptoConfig().model_dump()
        default_config['updated_at'] = default_config['updated_at'].isoformat()
        await db.crypto_config.insert_one(default_config)
        config = default_config
    
    # Get wallet addresses from settings
    settings = await db.settings.find_one({"id": "site_settings"}, {"_id": 0})
    crypto_settings = (settings or {}).get('crypto_settings') or {}
    if crypto_settings:
        config['crypto_settings'] = crypto_settings

    # Compatibility fields expected by frontend (CryptoPage)
    # Prefer site_settings.crypto_settings, fallback to crypto_config defaults.
    config['buy_rate_usdt'] = float(crypto_settings.get('buy_rate_usdt', config.get('buy_rate_bep20', 1.02)))
    config['sell_rate_usdt'] = float(crypto_settings.get('sell_rate_usdt', config.get('sell_rate_bep20', 0.98)))
    config['transaction_fee_percent'] = float(crypto_settings.get('transaction_fee_percent', config.get('buy_fee_percent', 2.0)))
    config['min_transaction_usd'] = float(crypto_settings.get('min_transaction_usd', config.get('min_buy_usd', 10.0)))
    
    return config

@api_router.put("/crypto/config")
async def update_crypto_config(updates: Dict[str, Any]):
    """Admin: Update crypto config"""
    updates['updated_at'] = datetime.now(timezone.utc).isoformat()
    
    result = await db.crypto_config.update_one(
        {"id": "crypto_config"},
        {"$set": updates},
        upsert=True
    )
    
    return {"message": "Crypto config updated"}

@api_router.post("/crypto/buy")
async def buy_crypto(request: CryptoBuyRequest, user_id: str = None, user_email: str = None):
    """User buys USDT - Generate Plisio invoice automatically"""
    # Extract user info from request if not provided
    if not user_id:
        user_id = "guest"
    if not user_email:
        user_email = "guest@kayicom.com"
    # Get config
    config = await db.crypto_config.find_one({"id": "crypto_config"})
    if not config:
        raise HTTPException(status_code=500, detail="Crypto config not found")
    
    # Get Plisio API key from settings
    settings = await db.settings.find_one({"id": "site_settings"})
    crypto_settings = (settings or {}).get("crypto_settings") or {}
    
    # For BUY USDT, customer pays with FIAT (PayPal, AirTM, Skrill)
    # No need for Plisio - just show admin payment info
    
    # Check limits (prefer site_settings.crypto_settings)
    min_usd = float(crypto_settings.get('min_transaction_usd', config.get('min_buy_usd', config.get('min_transaction_usd', 10.0))))
    max_usd = float(config.get('max_buy_usd', 10000.0))
    if request.amount_usd < min_usd or request.amount_usd > max_usd:
        raise HTTPException(status_code=400, detail=f"Amount must be between ${min_usd} and ${max_usd}")
    
    # Get rate
    rate_key = f"buy_rate_{request.chain.lower()}"
    exchange_rate = float(crypto_settings.get("buy_rate_usdt", config.get(rate_key, config.get("buy_rate_usdt", 1.02))))
    
    # Calculate
    amount_crypto = request.amount_usd / exchange_rate
    fee_percent = float(crypto_settings.get('transaction_fee_percent', config.get('buy_fee_percent', config.get('transaction_fee_percent', 2.0))))
    fee = request.amount_usd * (fee_percent / 100)
    total_usd = request.amount_usd + fee
    
    # Create transaction
    transaction = {
        "id": str(uuid.uuid4()),
        "user_id": user_id,
        "user_email": user_email,
        "transaction_type": "buy",
        "crypto_type": "USDT",
        "chain": request.chain,
        "amount_crypto": amount_crypto,
        "amount_usd": request.amount_usd,
        "exchange_rate": exchange_rate,
        "fee": fee,
        "total_usd": total_usd,
        "payment_method": request.payment_method,
        "wallet_address": request.wallet_address,
        "transaction_id": request.transaction_id,
        "payment_proof": request.payment_proof,
        "status": "pending",
        "created_at": datetime.now(timezone.utc).isoformat(),
        "updated_at": datetime.now(timezone.utc).isoformat()
    }
    
    await db.crypto_transactions.insert_one(transaction)
    
    # Get admin payment information based on selected method
    payment_info = {}
    if settings and settings.get('payment_gateways'):
        gateway = settings['payment_gateways'].get(request.payment_method, {})
        if gateway.get('enabled'):
            payment_info = {
                'method': request.payment_method,
                'email': gateway.get('email', ''),
                'instructions': gateway.get('instructions', '')
            }
    
    return {
        "message": "Buy crypto order created. Please send payment and submit proof.",
        "transaction_id": transaction['id'],
        "amount_crypto": amount_crypto,
        "total_usd": total_usd,
        "payment_info": payment_info
    }

@api_router.post("/crypto/sell")
async def sell_crypto(request: CryptoSellRequest, user_id: str, user_email: str):
    """User sells USDT"""
    config = await db.crypto_config.find_one({"id": "crypto_config"})
    if not config:
        raise HTTPException(status_code=500, detail="Crypto config not found")
    
    settings = await db.settings.find_one({"id": "site_settings"}, {"_id": 0})
    crypto_settings = (settings or {}).get("crypto_settings") or {}
    
    # Check limits
    min_sell = float(config.get('min_sell_usdt', 10.0))
    max_sell = float(config.get('max_sell_usdt', 10000.0))
    if request.amount_crypto < min_sell or request.amount_crypto > max_sell:
        raise HTTPException(status_code=400, detail=f"Amount must be between {min_sell} and {max_sell} USDT")
    
    # Get rate
    rate_key = f"sell_rate_{request.chain.lower()}"
    exchange_rate = float(crypto_settings.get("sell_rate_usdt", config.get(rate_key, config.get("sell_rate_usdt", 0.98))))
    
    # Calculate
    amount_usd = request.amount_crypto * exchange_rate
    fee_percent = float(crypto_settings.get('transaction_fee_percent', config.get('sell_fee_percent', config.get('transaction_fee_percent', 2.0))))
    fee = amount_usd * (fee_percent / 100)
    total_usd = amount_usd - fee
    
    transaction_id = str(uuid.uuid4())
    
    # Create Plisio invoice for receiving USDT from customer
    plisio_invoice = None
    
    if settings and settings.get('plisio_api_key'):
        try:
            plisio_helper = PlisioHelper(settings['plisio_api_key'])
            
            # Plisio uses just 'USDT' and handles chain automatically
            plisio_currency = 'USDT'
            
            plisio_result = await plisio_helper.create_invoice(
                amount=request.amount_crypto,
                currency=plisio_currency,
                order_name=f"Sell USDT Order",
                order_number=transaction_id,
                email=user_email
            )
            
            if plisio_result.get('success'):
                plisio_invoice = plisio_result
            else:
                print(f"Plisio invoice creation failed: {plisio_result.get('error')}")
        except Exception as e:
            print(f"Plisio integration error: {str(e)}")
            # Continue without Plisio integration
    
    # Create transaction
    transaction = {
        "id": transaction_id,
        "user_id": user_id,
        "user_email": user_email,
        "transaction_type": "sell",
        "crypto_type": "USDT",
        "chain": request.chain,
        "amount_crypto": request.amount_crypto,
        "amount_usd": amount_usd,
        "exchange_rate": exchange_rate,
        "fee": fee,
        "total_usd": total_usd,
        "payment_method": request.payment_method,
        "metadata": {"receiving_info": request.receiving_info},
        "receiving_info": request.receiving_info,
        "transaction_id": request.transaction_id,
        "payment_proof": request.payment_proof,
        "plisio_invoice_id": plisio_invoice.get('txn_id') if plisio_invoice else None,
        "status": "pending",
        "created_at": datetime.now(timezone.utc).isoformat(),
        "updated_at": datetime.now(timezone.utc).isoformat()
    }
    
    await db.crypto_transactions.insert_one(transaction)
    
    response = {
        "message": "Crypto sell order created. Send USDT to the address below",
        "transaction_id": transaction['id'],
        "total_usd_to_receive": total_usd,
        "amount_crypto": request.amount_crypto
    }
    
    # Add Plisio details if available
    if plisio_invoice:
        response['plisio'] = {
            "wallet_address": plisio_invoice.get("wallet_address"),
            "invoice_url": plisio_invoice.get("invoice_url"),
            "qr_code": plisio_invoice.get("qr_code"),
            "amount_crypto": plisio_invoice.get("amount_crypto"),
            "message": "Send USDT to this unique address. Payment will be automatically detected."
        }
    else:
        # Fallback to admin wallet if Plisio not available
        admin_wallets = crypto_settings.get("wallets") or {}
        response['wallet_address'] = admin_wallets.get(request.chain) or config.get(f"wallet_{request.chain.lower()}")
        response['message'] = "Send USDT to admin wallet. You'll need to provide transaction ID."
    
    return response

@api_router.get("/crypto/transactions/user/{user_id}")
async def get_user_crypto_transactions(user_id: str):
    """Get user's crypto transactions"""
    transactions = await db.crypto_transactions.find(
        {"user_id": user_id},
        {"_id": 0}
    ).sort("created_at", -1).to_list(100)
    
    return transactions

@api_router.get("/crypto/transactions/all")
async def get_all_crypto_transactions():
    """Admin: Get all crypto transactions"""
    transactions = await db.crypto_transactions.find(
        {},
        {"_id": 0}
    ).sort("created_at", -1).to_list(1000)
    
    return transactions

class CryptoStatusUpdate(BaseModel):
    status: str
    admin_notes: Optional[str] = None
    tx_hash: Optional[str] = None

@api_router.put("/crypto/transactions/{transaction_id}/status")
async def update_crypto_transaction_status(
    transaction_id: str,
    update_data: CryptoStatusUpdate
):
    """Admin: Update crypto transaction status"""
    if update_data.status not in ['processing', 'completed', 'rejected', 'failed']:
        raise HTTPException(status_code=400, detail="Invalid status")
    
    updates = {
        "status": update_data.status,
        "updated_at": datetime.now(timezone.utc).isoformat()
    }
    
    if update_data.admin_notes:
        updates['admin_notes'] = update_data.admin_notes
    
    if update_data.tx_hash:
        updates['tx_hash'] = update_data.tx_hash
    
    result = await db.crypto_transactions.update_one(
        {"id": transaction_id},
        {"$set": updates}
    )
    
    if result.modified_count == 0:
        raise HTTPException(status_code=404, detail="Transaction not found")
    
    return {"message": "Transaction status updated"}


# File Upload Endpoint
@api_router.post("/upload/image")
async def upload_image(file: UploadFile = File(...)):
    """Upload image and return base64 data URL"""
    try:
        # Read file content
        contents = await file.read()
        
        # Get mime type
        mime_type = file.content_type or mimetypes.guess_type(file.filename)[0] or 'image/jpeg'
        
        # Convert to base64
        base64_data = base64.b64encode(contents).decode('utf-8')
        data_url = f"data:{mime_type};base64,{base64_data}"
        
        return {"url": data_url, "filename": file.filename}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Upload failed: {str(e)}")

# ==================== REFERRAL PAYOUT TRACKING ====================

async def check_and_credit_referral(order: dict):
    """Check if order qualifies for referral payout and credit referrer"""
    # Only for paid + completed orders
    if order.get("payment_status") != "paid" or order.get("order_status") != "completed":
        return

    # Idempotency: don't pay twice for same order
    already_paid = await db.referral_payouts.find_one({"order_id": order.get("id")})
    if already_paid:
        return

    # Check if user was referred
    user = await db.users.find_one({"id": order['user_id']})
    if not user or not user.get('referred_by'):
        return
    
    # Check if order contains subscription
    subscription_product_ids: List[str] = []
    for item in order.get('items', []):
        product = await db.products.find_one({"id": item.get('product_id')})
        if product and product.get('is_subscription'):
            subscription_product_ids.append(product.get("id"))

    if not subscription_product_ids:
        return
    
    # Check if this is the first PAID+COMPLETED subscription order for this referred user
    prior_payout = await db.referral_payouts.find_one({"referred_user_id": order['user_id']})
    if prior_payout:
        return
    
    # Credit referrer $1
    referrer_code = user['referred_by']
    await db.users.update_one(
        {"referral_code": referrer_code},
        {"$inc": {"referral_balance": 1.0}}
    )
    
    # Log referral payout
    await db.referral_payouts.insert_one({
        "id": str(uuid.uuid4()),
        "referrer_code": referrer_code,
        "referred_user_id": order['user_id'],
        "order_id": order['id'],
        "amount": 1.0,
        "created_at": datetime.now(timezone.utc).isoformat()
    })


# ==================== WALLET (STORE CREDIT) ENDPOINTS ====================

class WalletAdjustment(BaseModel):
    amount: float
    reason: Optional[str] = None

class WalletTopupCreate(BaseModel):
    amount: float
    payment_method: str  # crypto_plisio or manual gateways

class WalletTopupProof(BaseModel):
    topup_id: str
    transaction_id: str
    payment_proof_url: str

class AdminWalletAdjustRequest(BaseModel):
    identifier: str  # user_id or customer_id or email
    amount: float
    reason: Optional[str] = None
    action: str = "credit"  # credit or debit


class CreditsConvertRequest(BaseModel):
    credits: int  # must be multiple of 100
    reason: Optional[str] = None


class AdminCreditsAdjustRequest(BaseModel):
    identifier: str  # user_id or customer_id or email
    credits: int
    reason: Optional[str] = None
    action: str = "credit"  # credit or debit

@api_router.get("/wallet/balance")
async def get_wallet_balance(user_id: str):
    user = await db.users.find_one({"id": user_id}, {"_id": 0})
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return {"user_id": user_id, "wallet_balance": float(user.get("wallet_balance", 0.0))}

@api_router.get("/wallet/transactions")
async def get_wallet_transactions(user_id: str):
    txs = await db.wallet_transactions.find({"user_id": user_id}, {"_id": 0}).sort("created_at", -1).to_list(200)
    return txs

@api_router.post("/wallet/admin-adjust")
async def admin_adjust_wallet(req: AdminWalletAdjustRequest):
    """
    Admin: credit/debit a user's wallet balance by user_id, customer_id, or email.
    (No auth implemented in this project.)
    """
    ident = (req.identifier or "").strip()
    if not ident:
        raise HTTPException(status_code=400, detail="Identifier required")
    amt = float(req.amount)
    if amt <= 0:
        raise HTTPException(status_code=400, detail="Amount must be > 0")
    if req.action not in ["credit", "debit"]:
        raise HTTPException(status_code=400, detail="Invalid action")

    user = await db.users.find_one(
        {"$or": [{"id": ident}, {"customer_id": ident}, {"email": ident}]},
        {"_id": 0}
    )
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    delta = amt if req.action == "credit" else -amt
    # If debit, prevent negative balance
    if delta < 0 and float(user.get("wallet_balance", 0.0)) + 1e-9 < abs(delta):
        raise HTTPException(status_code=400, detail="Insufficient wallet balance")

    await db.users.update_one({"id": user["id"]}, {"$inc": {"wallet_balance": float(delta)}})
    await db.wallet_transactions.insert_one({
        "id": str(uuid.uuid4()),
        "user_id": user["id"],
        "user_email": user.get("email"),
        "order_id": None,
        "type": "admin_adjust",
        "amount": float(delta),
        "reason": req.reason or f"Admin wallet {req.action}",
        "created_at": datetime.now(timezone.utc).isoformat()
    })

    updated = await db.users.find_one({"id": user["id"]}, {"_id": 0})
    return {"user_id": user["id"], "customer_id": user.get("customer_id"), "wallet_balance": float(updated.get("wallet_balance", 0.0))}


@api_router.get("/credits/balance")
async def get_credits_balance(user_id: str):
    user = await db.users.find_one({"id": user_id}, {"_id": 0})
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return {"user_id": user_id, "credits_balance": int(user.get("credits_balance", 0)), "rate": "100_credits = 1_USD"}


@api_router.get("/credits/transactions")
async def get_credits_transactions(user_id: str):
    txs = await db.credits_transactions.find({"user_id": user_id}, {"_id": 0}).sort("created_at", -1).to_list(200)
    return txs


@api_router.post("/credits/admin-adjust")
async def admin_adjust_credits(req: AdminCreditsAdjustRequest):
    """
    Admin: credit/debit a user's credits by user_id, customer_id, or email.
    (No auth implemented in this project.)
    """
    ident = (req.identifier or "").strip()
    if not ident:
        raise HTTPException(status_code=400, detail="Identifier required")
    credits = int(req.credits)
    if credits <= 0:
        raise HTTPException(status_code=400, detail="Credits must be > 0")
    if req.action not in ["credit", "debit"]:
        raise HTTPException(status_code=400, detail="Invalid action")

    user = await db.users.find_one(
        {"$or": [{"id": ident}, {"customer_id": ident}, {"email": ident}]},
        {"_id": 0}
    )
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    delta = credits if req.action == "credit" else -credits
    current = int(user.get("credits_balance", 0))
    if delta < 0 and current < abs(delta):
        raise HTTPException(status_code=400, detail="Insufficient credits")

    await db.users.update_one({"id": user["id"]}, {"$inc": {"credits_balance": int(delta)}})
    await db.credits_transactions.insert_one({
        "id": str(uuid.uuid4()),
        "user_id": user["id"],
        "user_email": user.get("email"),
        "order_id": None,
        "type": "admin_adjust",
        "credits": int(delta),
        "usd_equivalent": round(float(delta) / 100.0, 2),
        "reason": req.reason or f"Admin credits {req.action}",
        "created_at": datetime.now(timezone.utc).isoformat()
    })

    updated = await db.users.find_one({"id": user["id"]}, {"_id": 0})
    return {"user_id": user["id"], "customer_id": user.get("customer_id"), "credits_balance": int(updated.get("credits_balance", 0))}


@api_router.post("/credits/convert")
async def convert_credits_to_wallet(req: CreditsConvertRequest, user_id: str, user_email: str):
    credits = int(req.credits)
    if credits <= 0:
        raise HTTPException(status_code=400, detail="Credits must be > 0")
    if credits % 100 != 0:
        raise HTTPException(status_code=400, detail="Credits must be a multiple of 100")

    user = await db.users.find_one({"id": user_id}, {"_id": 0})
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    current = int(user.get("credits_balance", 0))
    if current < credits:
        raise HTTPException(status_code=400, detail="Insufficient credits")

    usd = round(float(credits) / 100.0, 2)
    await db.users.update_one({"id": user_id}, {"$inc": {"credits_balance": -credits, "wallet_balance": float(usd)}})

    await db.wallet_transactions.insert_one({
        "id": str(uuid.uuid4()),
        "user_id": user_id,
        "user_email": user_email,
        "order_id": None,
        "type": "credits_convert",
        "amount": float(usd),
        "reason": req.reason or f"Converted {credits} credits to wallet",
        "created_at": datetime.now(timezone.utc).isoformat()
    })
    await db.credits_transactions.insert_one({
        "id": str(uuid.uuid4()),
        "user_id": user_id,
        "user_email": user_email,
        "order_id": None,
        "type": "convert",
        "credits": -credits,
        "usd_equivalent": float(usd),
        "reason": req.reason or "Convert credits to wallet",
        "created_at": datetime.now(timezone.utc).isoformat()
    })

    updated = await db.users.find_one({"id": user_id}, {"_id": 0})
    return {"user_id": user_id, "credits_converted": credits, "usd_added": float(usd), "wallet_balance": float(updated.get("wallet_balance", 0.0)), "credits_balance": int(updated.get("credits_balance", 0))}

@api_router.post("/wallet/topups")
async def create_wallet_topup(topup: WalletTopupCreate, user_id: str, user_email: str):
    if float(topup.amount) <= 0:
        raise HTTPException(status_code=400, detail="Amount must be > 0")

    user_doc = await db.users.find_one({"id": user_id}, {"_id": 0})
    if not user_doc:
        raise HTTPException(status_code=404, detail="User not found")
    if user_doc.get("is_blocked"):
        raise HTTPException(status_code=403, detail="Account is blocked")

    settings = await db.settings.find_one({"id": "site_settings"}, {"_id": 0}) or {}

    topup_id = str(uuid.uuid4())
    doc = {
        "id": topup_id,
        "user_id": user_id,
        "user_email": user_email,
        "amount": float(topup.amount),
        "payment_method": topup.payment_method,
        "payment_status": "pending",
        "transaction_id": None,
        "payment_proof_url": None,
        "plisio_invoice_id": None,
        "plisio_invoice_url": None,
        "credited": False,
        "created_at": datetime.now(timezone.utc).isoformat(),
        "updated_at": datetime.now(timezone.utc).isoformat(),
    }

    # If crypto payment, create Plisio invoice
    if topup.payment_method == "crypto_plisio" and settings.get("plisio_api_key"):
        try:
            plisio = PlisioHelper(settings["plisio_api_key"])
            invoice_response = await plisio.create_invoice(
                amount=float(topup.amount),
                currency="USDT",
                order_name=f"Wallet Topup {topup_id}",
                order_number=topup_id,
                email=user_email,
            )
            if invoice_response.get("success"):
                doc["plisio_invoice_id"] = invoice_response.get("invoice_id")
                doc["plisio_invoice_url"] = invoice_response.get("invoice_url")
        except Exception as e:
            logging.error(f"Plisio topup error: {e}")

    await db.wallet_topups.insert_one(doc)

    # Attach payment instructions for manual methods (optional)
    payment_info = {}
    gateways = settings.get("payment_gateways") or {}
    gateway = gateways.get(topup.payment_method) or {}
    if gateway.get("enabled"):
        payment_info = {
            "method": topup.payment_method,
            "email": gateway.get("email", ""),
            "instructions": gateway.get("instructions", "")
        }

    return {"topup": doc, "payment_info": payment_info}

@api_router.get("/wallet/topups/user/{user_id}")
async def get_user_wallet_topups(user_id: str):
    topups = await db.wallet_topups.find({"user_id": user_id}, {"_id": 0}).sort("created_at", -1).to_list(200)
    return topups

@api_router.get("/wallet/topups/all")
async def get_all_wallet_topups():
    topups = await db.wallet_topups.find({}, {"_id": 0}).sort("created_at", -1).to_list(1000)
    return topups

@api_router.post("/wallet/topups/proof")
async def submit_wallet_topup_proof(proof: WalletTopupProof):
    res = await db.wallet_topups.update_one(
        {"id": proof.topup_id},
        {"$set": {
            "transaction_id": proof.transaction_id,
            "payment_proof_url": proof.payment_proof_url,
            "payment_status": "pending_verification",
            "updated_at": datetime.now(timezone.utc).isoformat()
        }}
    )
    if res.matched_count == 0:
        raise HTTPException(status_code=404, detail="Topup not found")
    return {"message": "Topup proof submitted"}

@api_router.put("/wallet/topups/{topup_id}/status")
async def update_wallet_topup_status(topup_id: str, payment_status: str):
    if payment_status not in ["paid", "failed", "rejected", "processing"]:
        raise HTTPException(status_code=400, detail="Invalid status")

    topup = await db.wallet_topups.find_one({"id": topup_id}, {"_id": 0})
    if not topup:
        raise HTTPException(status_code=404, detail="Topup not found")

    await db.wallet_topups.update_one(
        {"id": topup_id},
        {"$set": {"payment_status": payment_status, "updated_at": datetime.now(timezone.utc).isoformat()}}
    )

    # Credit wallet once when marked paid
    if payment_status == "paid" and not topup.get("credited"):
        await db.users.update_one({"id": topup["user_id"]}, {"$inc": {"wallet_balance": float(topup["amount"])}})
        await db.wallet_transactions.insert_one({
            "id": str(uuid.uuid4()),
            "user_id": topup["user_id"],
            "user_email": topup.get("user_email"),
            "order_id": None,
            "type": "topup",
            "amount": float(topup["amount"]),
            "reason": f"Wallet topup {topup_id}",
            "created_at": datetime.now(timezone.utc).isoformat()
        })
        await db.wallet_topups.update_one({"id": topup_id}, {"$set": {"credited": True}})

    return {"message": "Topup updated"}


# ==================== MINUTES TRANSFER (INTERNATIONAL) ====================

class MinutesQuoteResponse(BaseModel):
    amount: float
    fee_amount: float
    total_amount: float
    currency: str = "USD"


class MinutesTransferCreate(BaseModel):
    country: str
    phone_number: str
    amount: float  # USD amount customer wants to send
    payment_method: str  # wallet, crypto_plisio, or manual gateways


class MinutesTransferProof(BaseModel):
    transfer_id: str
    transaction_id: str
    payment_proof_url: str


class MinutesTransferStatusUpdate(BaseModel):
    payment_status: Optional[str] = None  # pending, pending_verification, paid, failed, rejected, processing
    transfer_status: Optional[str] = None  # pending, processing, completed, cancelled


def _calc_minutes_fee(settings: dict, amount: float) -> Dict[str, float]:
    fee_type = (settings or {}).get("minutes_transfer_fee_type") or "percent"
    fee_value = float((settings or {}).get("minutes_transfer_fee_value") or 0.0)
    if fee_type not in ["percent", "fixed"]:
        fee_type = "percent"
    if fee_type == "percent":
        fee_amount = amount * max(0.0, fee_value) / 100.0
    else:
        fee_amount = max(0.0, fee_value)
    fee_amount = round(float(fee_amount), 2)
    total = round(float(amount + fee_amount), 2)
    return {"fee_amount": fee_amount, "total_amount": total}


@api_router.get("/minutes/quote", response_model=MinutesQuoteResponse)
@api_router.get("/mobile-topup/quote", response_model=MinutesQuoteResponse)
async def minutes_quote(amount: float, country: Optional[str] = None):
    settings = await db.settings.find_one({"id": "site_settings"}, {"_id": 0}) or {}
    if not settings.get("minutes_transfer_enabled"):
        raise HTTPException(status_code=400, detail="Minutes transfer is disabled")

    amt = float(amount)
    if amt <= 0:
        raise HTTPException(status_code=400, detail="Amount must be > 0")
    min_amt = float(settings.get("minutes_transfer_min_amount") or 1.0)
    max_amt = float(settings.get("minutes_transfer_max_amount") or 500.0)
    if amt + 1e-9 < min_amt or amt - 1e-9 > max_amt:
        raise HTTPException(status_code=400, detail=f"Amount must be between {min_amt} and {max_amt}")

    fee = _calc_minutes_fee(settings, amt)
    return {"amount": round(amt, 2), "fee_amount": fee["fee_amount"], "total_amount": fee["total_amount"], "currency": "USD"}


@api_router.post("/minutes/transfers")
@api_router.post("/mobile-topup/requests")
async def create_minutes_transfer(payload: MinutesTransferCreate, user_id: str, user_email: str):
    settings = await db.settings.find_one({"id": "site_settings"}, {"_id": 0}) or {}
    if not settings.get("minutes_transfer_enabled"):
        raise HTTPException(status_code=400, detail="Minutes transfer is disabled")

    user_doc = await db.users.find_one({"id": user_id}, {"_id": 0})
    if not user_doc:
        raise HTTPException(status_code=404, detail="User not found")
    if user_doc.get("is_blocked"):
        raise HTTPException(status_code=403, detail="Account is blocked")

    country = (payload.country or "").strip()
    phone = (payload.phone_number or "").strip()
    if not country or not phone:
        raise HTTPException(status_code=400, detail="Country and phone number are required")

    amt = float(payload.amount)
    min_amt = float(settings.get("minutes_transfer_min_amount") or 1.0)
    max_amt = float(settings.get("minutes_transfer_max_amount") or 500.0)
    if amt <= 0:
        raise HTTPException(status_code=400, detail="Amount must be > 0")
    if amt + 1e-9 < min_amt or amt - 1e-9 > max_amt:
        raise HTTPException(status_code=400, detail=f"Amount must be between {min_amt} and {max_amt}")

    fee = _calc_minutes_fee(settings, amt)
    transfer_id = str(uuid.uuid4())
    doc = {
        "id": transfer_id,
        "user_id": user_id,
        "user_email": user_email,
        "country": country,
        "phone_number": phone,
        "amount": round(float(amt), 2),
        "fee_amount": fee["fee_amount"],
        "total_amount": fee["total_amount"],
        "payment_method": payload.payment_method,
        "payment_status": "pending",
        "transfer_status": "pending",
        "transaction_id": None,
        "payment_proof_url": None,
        "plisio_invoice_id": None,
        "plisio_invoice_url": None,
        "created_at": datetime.now(timezone.utc).isoformat(),
        "updated_at": datetime.now(timezone.utc).isoformat(),
    }

    # Payment validation
    if payload.payment_method == "wallet":
        wallet_balance = float(user_doc.get("wallet_balance", 0.0))
        if wallet_balance + 1e-9 < float(doc["total_amount"]):
            raise HTTPException(status_code=400, detail="Insufficient wallet balance")
        await db.users.update_one({"id": user_id}, {"$inc": {"wallet_balance": -float(doc["total_amount"])}})
        await db.wallet_transactions.insert_one({
            "id": str(uuid.uuid4()),
            "user_id": user_id,
            "user_email": user_email,
            "order_id": None,
            "type": "minutes_transfer",
            "amount": -float(doc["total_amount"]),
            "reason": f"Minutes transfer {transfer_id}",
            "created_at": datetime.now(timezone.utc).isoformat()
        })
        doc["payment_status"] = "paid"
        doc["transfer_status"] = "processing"

    elif payload.payment_method == "crypto_plisio":
        if not settings.get("plisio_api_key"):
            raise HTTPException(status_code=400, detail="Plisio not configured")
        try:
            plisio = PlisioHelper(settings["plisio_api_key"])
            invoice_response = await plisio.create_invoice(
                amount=float(doc["total_amount"]),
                currency="USDT",
                order_name=f"Minutes Transfer {transfer_id}",
                order_number=transfer_id,
                email=user_email,
            )
            if invoice_response.get("success"):
                doc["plisio_invoice_id"] = invoice_response.get("invoice_id")
                doc["plisio_invoice_url"] = invoice_response.get("invoice_url")
        except Exception as e:
            logging.error(f"Plisio minutes transfer error: {e}")
    else:
        gateways = settings.get("payment_gateways") or {}
        gateway = gateways.get(payload.payment_method) or {}
        if not gateway.get("enabled"):
            raise HTTPException(status_code=400, detail="Payment method not enabled")

    await db.minutes_transfers.insert_one(doc)

    payment_info = {}
    if payload.payment_method not in ["wallet", "crypto_plisio"]:
        gateways = settings.get("payment_gateways") or {}
        gateway = gateways.get(payload.payment_method) or {}
        if gateway.get("enabled"):
            payment_info = {
                "method": payload.payment_method,
                "email": gateway.get("email", ""),
                "instructions": gateway.get("instructions", ""),
            }
    if settings.get("minutes_transfer_instructions"):
        payment_info["service_instructions"] = settings.get("minutes_transfer_instructions")

    return {"transfer": doc, "payment_info": payment_info}


@api_router.get("/minutes/transfers/user/{user_id}")
@api_router.get("/mobile-topup/requests/user/{user_id}")
async def get_user_minutes_transfers(user_id: str):
    transfers = await db.minutes_transfers.find({"user_id": user_id}, {"_id": 0}).sort("created_at", -1).to_list(200)
    return transfers


@api_router.get("/minutes/transfers/all")
@api_router.get("/mobile-topup/requests/all")
async def get_all_minutes_transfers():
    transfers = await db.minutes_transfers.find({}, {"_id": 0}).sort("created_at", -1).to_list(1000)
    return transfers


@api_router.post("/minutes/transfers/proof")
@api_router.post("/mobile-topup/requests/proof")
async def submit_minutes_transfer_proof(proof: MinutesTransferProof):
    res = await db.minutes_transfers.update_one(
        {"id": proof.transfer_id},
        {"$set": {
            "transaction_id": proof.transaction_id,
            "payment_proof_url": proof.payment_proof_url,
            "payment_status": "pending_verification",
            "updated_at": datetime.now(timezone.utc).isoformat()
        }}
    )
    if res.matched_count == 0:
        raise HTTPException(status_code=404, detail="Transfer not found")
    return {"message": "Payment proof submitted"}


@api_router.put("/minutes/transfers/{transfer_id}/status")
@api_router.put("/mobile-topup/requests/{transfer_id}/status")
async def update_minutes_transfer_status(transfer_id: str, updates: MinutesTransferStatusUpdate):
    update_data = {}
    if updates.payment_status is not None:
        if updates.payment_status not in ["pending", "pending_verification", "paid", "failed", "rejected", "processing", "cancelled"]:
            raise HTTPException(status_code=400, detail="Invalid payment_status")
        update_data["payment_status"] = updates.payment_status
    if updates.transfer_status is not None:
        if updates.transfer_status not in ["pending", "processing", "completed", "cancelled"]:
            raise HTTPException(status_code=400, detail="Invalid transfer_status")
        update_data["transfer_status"] = updates.transfer_status

    if not update_data:
        raise HTTPException(status_code=400, detail="No updates provided")

    update_data["updated_at"] = datetime.now(timezone.utc).isoformat()
    res = await db.minutes_transfers.update_one({"id": transfer_id}, {"$set": update_data})
    if res.matched_count == 0:
        raise HTTPException(status_code=404, detail="Transfer not found")
    updated = await db.minutes_transfers.find_one({"id": transfer_id}, {"_id": 0})
    return updated or {"message": "Updated"}

@api_router.post("/orders/{order_id}/refund")
async def refund_order_to_wallet(order_id: str, adjustment: WalletAdjustment):
    """
    Refund an order to the user's wallet (store credit).
    This is intended for admin use (no auth implemented in this project).
    """
    order = await db.orders.find_one({"id": order_id}, {"_id": 0})
    if not order:
        raise HTTPException(status_code=404, detail="Order not found")

    if order.get("refunded_at"):
        raise HTTPException(status_code=400, detail="Order already refunded")

    if float(adjustment.amount) <= 0:
        raise HTTPException(status_code=400, detail="Refund amount must be > 0")

    user_id = order.get("user_id")
    user_email = order.get("user_email")

    # Credit wallet
    await db.users.update_one({"id": user_id}, {"$inc": {"wallet_balance": float(adjustment.amount)}})
    await db.wallet_transactions.insert_one({
        "id": str(uuid.uuid4()),
        "user_id": user_id,
        "user_email": user_email,
        "order_id": order_id,
        "type": "refund",
        "amount": float(adjustment.amount),
        "reason": adjustment.reason or "Order refund",
        "created_at": datetime.now(timezone.utc).isoformat()
    })

    # Update order
    await db.orders.update_one(
        {"id": order_id},
        {"$set": {
            "order_status": "cancelled",
            "payment_status": "cancelled",
            "refunded_amount": float(adjustment.amount),
            "refunded_at": datetime.now(timezone.utc).isoformat(),
            "updated_at": datetime.now(timezone.utc).isoformat()
        }}
    )

    return {"message": "Refunded to wallet", "user_id": user_id, "amount": float(adjustment.amount)}

# Modify order status endpoint to trigger referral check
@api_router.put("/orders/{order_id}/complete")
async def complete_order_with_referral_check(order_id: str):
    """Complete order and check for referral payout"""
    order = await db.orders.find_one({"id": order_id})
    if not order:
        raise HTTPException(status_code=404, detail="Order not found")
    
    # Update order status
    await db.orders.update_one(
        {"id": order_id},
        {"$set": {
            "order_status": "completed",
            "payment_status": "paid",
            "updated_at": datetime.now(timezone.utc).isoformat()
        }}
    )

    await _record_coupon_usage_if_needed(order_id)
    await _set_subscription_dates_if_needed(order_id)
    updated = await db.orders.find_one({"id": order_id}, {"_id": 0})
    try:
        await _maybe_send_subscription_emails(updated or order)
    except Exception as e:
        logging.error(f"Subscription email check error: {e}")
    
    # Check and credit referral
    await check_and_credit_referral(order)

    # Award loyalty credits for successful order
    await _record_loyalty_credits_if_needed(order_id)
    
    return {"message": "Order completed"}

# Include the router (must be after all endpoints are defined)
app.include_router(api_router)

@app.on_event("shutdown")
async def shutdown_db_client():
    client.close()
